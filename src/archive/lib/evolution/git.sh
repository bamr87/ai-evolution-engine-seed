#!/bin/bash
# Git operations library for AI Evolution Engine
# Provides consistent git operations across all scripts
# Version: 0.3.6-seed

# Source dependencies
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/../core/logger.sh"

# Git configuration
readonly DEFAULT_BRANCH="main"
readonly EVOLUTION_BRANCH_PREFIX="evolution"
readonly GROWTH_BRANCH_PREFIX="growth"

# Initialize git repository
init_git_repo() {
    local repo_dir="${1:-.}"
    
    log_info "Initializing Git repository..."
    
    cd "$repo_dir" || return 1
    
    if [[ ! -d ".git" ]]; then
        git init
        log_success "Git repository initialized"
    else
        log_info "Git repository already exists"
    fi
    
    # Set default branch if needed
    local current_branch=$(git symbolic-ref --short HEAD 2>/dev/null || echo "")
    if [[ -z "$current_branch" ]] || [[ "$current_branch" != "$DEFAULT_BRANCH" ]]; then
        git checkout -b "$DEFAULT_BRANCH" 2>/dev/null || true
        log_info "Set default branch to $DEFAULT_BRANCH"
    fi
    
    return 0
}

# Check if repository is clean
is_repo_clean() {
    if [[ -z "$(git status --porcelain)" ]]; then
        return 0
    else
        return 1
    fi
}

# Get current branch
get_current_branch() {
    git symbolic-ref --short HEAD 2>/dev/null || git rev-parse --short HEAD
}

# Create evolution branch
create_evolution_branch() {
    local evolution_type="$1"
    local timestamp="${2:-$(date +%Y%m%d-%H%M%S)}"
    local branch_name="$EVOLUTION_BRANCH_PREFIX/$timestamp-$evolution_type"
    
    log_info "Creating evolution branch: $branch_name"
    
    # Ensure we're on the default branch
    git checkout "$DEFAULT_BRANCH" 2>/dev/null || {
        log_error "Failed to checkout default branch"
        return 1
    }
    
    # Pull latest changes
    if git remote | grep -q origin; then
        log_info "Pulling latest changes..."
        git pull origin "$DEFAULT_BRANCH" 2>/dev/null || log_warn "Failed to pull latest changes"
    fi
    
    # Create and checkout new branch
    git checkout -b "$branch_name" || {
        log_error "Failed to create branch: $branch_name"
        return 1
    }
    
    log_success "Created and switched to branch: $branch_name"
    echo "$branch_name"
    return 0
}

# Create growth branch
create_growth_branch() {
    local growth_mode="$1"
    local cycle="${2:-unknown}"
    local timestamp="${3:-$(date +%Y%m%d-%H%M%S)}"
    local branch_name="$GROWTH_BRANCH_PREFIX/$timestamp-$growth_mode-cycle$cycle"
    
    log_info "Creating growth branch: $branch_name"
    
    git checkout -b "$branch_name" || {
        log_error "Failed to create growth branch: $branch_name"
        return 1
    }
    
    log_success "Created growth branch: $branch_name"
    echo "$branch_name"
    return 0
}

# Stage files for commit
stage_files() {
    local files=("$@")
    
    if [[ ${#files[@]} -eq 0 ]]; then
        # Stage all changes
        log_info "Staging all changes..."
        git add -A
    else
        # Stage specific files
        log_info "Staging specified files..."
        for file in "${files[@]}"; do
            if [[ -e "$file" ]]; then
                git add "$file"
                log_debug "Staged: $file"
            else
                log_warn "File not found: $file"
            fi
        done
    fi
    
    # Show what was staged
    local staged_files=$(git diff --cached --name-only)
    if [[ -n "$staged_files" ]]; then
        log_info "Staged files:"
        echo "$staged_files" | while read -r file; do
            log_info "  $file"
        done
    else
        log_warn "No files staged for commit"
        return 1
    fi
    
    return 0
}

# Create commit with evolution metadata
create_evolution_commit() {
    local message="$1"
    local evolution_type="${2:-unknown}"
    local cycle="${3:-0}"
    local generation="${4:-0}"
    
    # Validate that we have staged changes
    if [[ -z "$(git diff --cached --name-only)" ]]; then
        log_warn "No staged changes to commit"
        return 1
    fi
    
    # Create detailed commit message
    local full_message="$message

Evolution Details:
- Type: $evolution_type
- Cycle: $cycle
- Generation: $generation
- Timestamp: $(date -Iseconds)
- Branch: $(get_current_branch)

Auto-generated by AI Evolution Engine v1.0.0"
    
    log_info "Creating evolution commit..."
    git commit -m "$full_message" || {
        log_error "Failed to create commit"
        return 1
    }
    
    local commit_hash=$(git rev-parse --short HEAD)
    log_success "Created commit: $commit_hash"
    echo "$commit_hash"
    return 0
}

# Push branch to remote
push_branch() {
    local branch_name="${1:-$(get_current_branch)}"
    local remote="${2:-origin}"
    
    log_info "Pushing branch $branch_name to $remote..."
    
    # Check if remote exists
    if ! git remote | grep -q "$remote"; then
        log_warn "Remote '$remote' not found - skipping push"
        return 0
    fi
    
    # Push branch
    if git push -u "$remote" "$branch_name"; then
        log_success "Successfully pushed branch: $branch_name"
        return 0
    else
        log_error "Failed to push branch: $branch_name"
        return 1
    fi
}

# Create pull request (requires GitHub CLI)
create_pull_request() {
    local title="$1"
    local body="$2"
    local base_branch="${3:-$DEFAULT_BRANCH}"
    local head_branch="${4:-$(get_current_branch)}"
    
    log_info "Creating pull request..."
    
    # Check if gh is available
    if ! command -v gh >/dev/null 2>&1; then
        log_error "GitHub CLI (gh) is required to create pull requests"
        return 1
    fi
    
    # Check if we're authenticated
    if ! gh auth status >/dev/null 2>&1; then
        log_error "GitHub CLI is not authenticated. Run: gh auth login"
        return 1
    fi
    
    # Create PR
    local pr_url
    if pr_url=$(gh pr create \
        --title "$title" \
        --body "$body" \
        --base "$base_branch" \
        --head "$head_branch" \
        --draft 2>/dev/null); then
        log_success "Created pull request: $pr_url"
        echo "$pr_url"
        return 0
    else
        log_error "Failed to create pull request"
        return 1
    fi
}

# Get repository information
get_repo_info() {
    local info_format="${1:-json}"
    
    case "$info_format" in
        "json")
            cat << EOF
{
  "current_branch": "$(get_current_branch)",
  "is_clean": $(is_repo_clean && echo "true" || echo "false"),
  "last_commit": "$(git log -1 --format='%H' 2>/dev/null || echo 'none')",
  "last_commit_message": "$(git log -1 --format='%s' 2>/dev/null || echo 'none')",
  "remote_url": "$(git remote get-url origin 2>/dev/null || echo 'none')",
  "total_commits": $(git rev-list --count HEAD 2>/dev/null || echo 0),
  "staged_files": $(git diff --cached --name-only | jq -R -s 'split("\n")[:-1]'),
  "modified_files": $(git diff --name-only | jq -R -s 'split("\n")[:-1]'),
  "untracked_files": $(git ls-files --others --exclude-standard | jq -R -s 'split("\n")[:-1]')
}
EOF
            ;;
        "summary")
            echo "Repository Summary:"
            echo "  Branch: $(get_current_branch)"
            echo "  Status: $(is_repo_clean && echo "Clean" || echo "Modified")"
            echo "  Last commit: $(git log -1 --format='%h %s' 2>/dev/null || echo 'None')"
            echo "  Remote: $(git remote get-url origin 2>/dev/null || echo 'None')"
            ;;
        *)
            log_error "Unknown format: $info_format"
            return 1
            ;;
    esac
}

# Cleanup branches
cleanup_evolution_branches() {
    local keep_count="${1:-5}"
    local dry_run="${2:-false}"
    
    log_info "Cleaning up old evolution branches (keeping $keep_count most recent)..."
    
    # Get evolution branches sorted by date
    local evolution_branches
    evolution_branches=$(git branch | grep -E "$EVOLUTION_BRANCH_PREFIX|$GROWTH_BRANCH_PREFIX" | sed 's/^[* ] //' | sort -r)
    
    local count=0
    while IFS= read -r branch; do
        ((count++))
        if [[ $count -le $keep_count ]]; then
            log_debug "Keeping branch: $branch"
        else
            if [[ "$dry_run" == "true" ]]; then
                log_info "Would delete branch: $branch (dry run)"
            else
                log_info "Deleting branch: $branch"
                git branch -D "$branch" 2>/dev/null || log_warn "Failed to delete branch: $branch"
            fi
        fi
    done <<< "$evolution_branches"
    
    log_success "Branch cleanup completed"
}

# Restore working directory to clean state
restore_clean_state() {
    local target_branch="${1:-$DEFAULT_BRANCH}"
    
    log_info "Restoring clean state on branch: $target_branch"
    
    # Stash any uncommitted changes
    if ! is_repo_clean; then
        log_info "Stashing uncommitted changes..."
        git stash push -m "Auto-stash before restore: $(date)"
    fi
    
    # Checkout target branch
    git checkout "$target_branch" || {
        log_error "Failed to checkout branch: $target_branch"
        return 1
    }
    
    # Pull latest changes if remote exists
    if git remote | grep -q origin; then
        log_info "Pulling latest changes..."
        git pull origin "$target_branch" 2>/dev/null || log_warn "Failed to pull latest changes"
    fi
    
    log_success "Restored clean state on $target_branch"
    return 0
}
