name: ðŸŒ± AI Evolution Growth Engine (v0.2.0)

on:
  workflow_dispatch:
    inputs:
      prompt:
        description: 'Growth instructions for the AI (e.g., "Implement user authentication")'
        required: true
        type: string
      growth_mode:
        description: 'Growth strategy (conservative, adaptive, experimental)'
        required: false
        default: 'adaptive'
        type: choice
        options:
          - conservative
          - adaptive
          - experimental
      auto_plant_seeds: # This now refers to auto-committing the new .seed.md
        description: 'Automatically commit the newly generated .seed.md for next evolution?'
        required: false
        default: true
        type: boolean

permissions:
  contents: write
  pull-requests: write
  issues: write # If AI needs to create issues for complex tasks

jobs:
  evolve:
    name: ðŸŒ¿ Growth Cycle v0.2.0
    runs-on: ubuntu-latest
    
    steps:
      - name: ðŸŒ± Prepare Growth Environment
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Need full history for some context, potentially
          
      - name: ðŸ§¬ Collect Repository DNA & Metrics
        id: collect_context
        run: |
          echo "ðŸ§¬ Analyzing repository genome and current metrics..."
          CONTEXT_FILE="/tmp/repo_context.json"
          
          # Initialize context with metadata and metrics
          METRICS_CONTENT=$(cat evolution-metrics.json || echo '{}')
          jq -n \
            --argjson metrics "$METRICS_CONTENT" \
            --arg prompt "${{ inputs.prompt }}" \
            --arg growth_mode "${{ inputs.growth_mode }}" \
            '{
              "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
              "user_prompt": $prompt,
              "growth_mode": $growth_mode,
              "current_metrics": $metrics,
              "repository_structure": $(tree -J -L 3 -I ".git|node_modules|venv|dist|build" || echo "[]"),
              "files": {}
            }' > "$CONTEXT_FILE"

          # Add file contents (respecting .gptignore if present, else common ignores)
          IGNORE_PATTERNS='\.git|\.DS_Store|node_modules|venv|env|dist|build|\*.pyc|__pycache__|\*.log|\*.tmp|\*.swp'
          if [ -f .gptignore ]; then
            GPTIGNORE_PATTERNS=$(cat .gptignore | grep -v '^#' | grep -v '^[[:space:]]*$' | sed 's|/$|/.*|' | paste -sd '|')
            if [ -n "$GPTIGNORE_PATTERNS" ]; then
              IGNORE_PATTERNS="$IGNORE_PATTERNS|$GPTIGNORE_PATTERNS"
            fi
          fi
          
          find . -type f | grep -Ev "$IGNORE_PATTERNS" | head -n $(jq -r '.evolution.max_context_files // 50' .evolution.yml 2>/dev/null || echo 50) | \
          while IFS= read -r file; do
            echo "Adding $file to context..."
            # Ensure file path is a valid JSON string key
            file_key=$(echo "$file" | sed 's|^\./||')
            jq --arg path "$file_key" \
               --arg content "$(cat "$file" | head -n $(jq -r '.evolution.max_context_line_per_file // 1000' .evolution.yml 2>/dev/null || echo 1000))" \
              '.files[$path] = $content' "$CONTEXT_FILE" > "${CONTEXT_FILE}.tmp" && mv "${CONTEXT_FILE}.tmp" "$CONTEXT_FILE"
          done
          echo "Context collected in $CONTEXT_FILE"
          cat $CONTEXT_FILE # For debugging
          
      - name: ðŸ§  Invoke Simulated AI Growth Engine
        id: ai_growth_simulation
        run: |
          echo "ðŸ§  Simulating AI growth cycle based on prompt: ${{ inputs.prompt }}"
          CONTEXT_FILE="/tmp/repo_context.json"
          RESPONSE_FILE="/tmp/evolution_response.json"
          
          CURRENT_METRICS_JSON=$(jq -r '.current_metrics' "$CONTEXT_FILE")
          CURRENT_CYCLE=$(echo "$CURRENT_METRICS_JSON" | jq -r '.growth_cycles // 0')
          CURRENT_GENERATION=$(echo "$CURRENT_METRICS_JSON" | jq -r '.current_generation // 0')
          NEW_CYCLE=$((CURRENT_CYCLE + 1))
          NEW_GENERATION=$((CURRENT_GENERATION + 1)) # Simple increment for simulation

          # Simulate updating evolution-metrics.json
          NEW_METRICS_CONTENT=$(echo "$CURRENT_METRICS_JSON" | jq \
            --arg new_cycle "$NEW_CYCLE" \
            --arg new_gen "$NEW_GENERATION" \
            --arg last_prompt "${{ inputs.prompt }}" \
            --arg last_growth "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            '.growth_cycles = ($new_cycle | tonumber) |
             .current_generation = ($new_gen | tonumber) |
             .adaptations_logged += 1 |
             .last_growth_spurt = $last_growth |
             .last_prompt = $last_prompt |
             .evolution_history += [{"cycle": ($new_cycle | tonumber), "prompt": $last_prompt, "timestamp": $last_growth}]')
          
          # Simulate updating README.md
          # This will replace the content between the markers
          README_MARKER_START="<!-- AI-EVOLUTION-MARKER:START -->"
          README_MARKER_END="<!-- AI-EVOLUTION-MARKER:END -->"
          NEW_README_DYNAMIC_CONTENT="**Evolutionary State:**\n- Generation: $NEW_GENERATION\n- Adaptations Logged: $(echo "$NEW_METRICS_CONTENT" | jq .adaptations_logged)\n- Last Growth Spurt: $(echo "$NEW_METRICS_CONTENT" | jq .last_growth_spurt)\n- Last Prompt: ${{ inputs.prompt }}"
          
          # Read existing README, replace marker section (crude sed for multiline)
          # A more robust solution would use a proper templating engine or smarter AI replacement
          # For this simulation, we'll generate the whole README content
          CURRENT_README_CONTENT=$(cat README.md)
          # This is a simplified way to replace a block. A real AI might regenerate more.
          # Escaping for sed is tricky with arbitrary content.
          # So, for simplicity, the AI will provide the *full new README content*.
          # Let's build the new README content by replacing the dynamic block.
          # This is still complex for pure shell. Let's assume the AI generates the full new README.
          # For simulation, we'll just prepare the text that *would* go into the full README.
          # The actual replacement will be done by creating a new README.md file.

          # Construct the new README content (simplified)
          # This is a placeholder for a more sophisticated README update.
          # In a real scenario, the AI would craft this. Here, we just update the marker section.
          # For the simulation, we'll provide the *entire* new README content.
          # This is a bit of a cheat for the simulation, but easier to implement.
          # A real AI would be smarter.
          # The 'changes' array will carry this full content.
          # This part assumes the AI can reconstruct the README with the new stats.
          # For this simulation, we'll crudely replace the block.
          # This is still tricky. The AI response will just provide the NEW full README.

          # Let's make the AI generate the *entire* content for README.md and evolution-metrics.json
          # This simplifies the "Apply Growth Changes" step.
          
          # For README.md: Read existing, then try to replace the section.
          # This is a complex task for shell scripting if new_content has many special chars.
          # Alternative: AI generates full new README.
          # Let's stick to the "AI generates full file content" for changed files.

          # Generate new README.md content (Simulated AI creates this)
          # For now, we'll just focus on the metrics part and assume the rest is handled.
          # The AI would ideally get the README template and fill it.
          # For simulation, let's create a "new" README content string here.
          # This is a simplified example. A real AI would be much more sophisticated.
          # We will replace the content between markers in the existing README.
          # This is still hard. Let's assume the AI generates the full README content.
          # This is a placeholder for the AI's README generation.
          # It should take the existing README structure and update the dynamic part.
          
          # Read the original README content
          ORIGINAL_README_CONTENT=$(cat README.md)
          # Prepare the new dynamic content block
          DYNAMIC_BLOCK_CONTENT="    **Evolutionary State:**\n    - Generation: $NEW_GENERATION\n    - Adaptations Logged: $(echo "$NEW_METRICS_CONTENT" | jq -r .adaptations_logged)\n    - Last Growth Spurt: $(echo "$NEW_METRICS_CONTENT" | jq -r .last_growth_spurt)\n    - Last Prompt: ${{ inputs.prompt }}"
          # Use awk to replace content between markers. Relies on markers being on their own lines.
          # This is still fragile. If AI provides full content, it's more robust.
          # Let's go with: AI provides the *full* new README.md content.
          # For simulation, we'll just generate a new README string based on the old one + new stats.
          # This is too complex to do robustly in bash for the simulation.
          # The "evolution_response.json" will contain the *full text* for modified files.
          
          # Placeholder for full new README content generation by AI
          # This is where a real LLM would be prompted with the old README and new stats.
          # For simulation, we'll just indicate it changed.
          # For a better simulation, one could use sed to replace the block, but it's tricky.
          # For now, the "change" will be to evolution-metrics.json and a new .seed.md.
          # README update will be a simplified "touch" or small modification.
          # Let's make the AI output the *new content for the dynamic block only*.
          # And the apply step will use sed. This is more realistic for an AI.

          # Simulated AI generates new content for the dynamic block in README.md
          README_DYNAMIC_CONTENT_FOR_AI_RESPONSE="    **Evolutionary State:**\\n    - Generation: $NEW_GENERATION\\n    - Adaptations Logged: $(echo "$NEW_METRICS_CONTENT" | jq -r .adaptations_logged)\\n    - Last Growth Spurt: $(echo "$NEW_METRICS_CONTENT" | jq -r .last_growth_spurt)\\n    - Last Prompt: ${{ inputs.prompt }}"


          # Content for the next .seed.md
          NEXT_SEED_CONTENT=$(cat <<EOF_NEXT_SEED
          # ðŸŒ± AI Evolution Engine - Evolved Seed (Candidate for v0.3.0) ðŸŒ±

          This seed was generated after growth cycle **#$NEW_CYCLE**.
          **Prompt for this cycle:** "${{ inputs.prompt }}"
          **Growth Mode:** ${{ inputs.growth_mode }}

          ## ðŸŒ¿ Evolutionary Leap Summary

          This cycle (simulated) focused on:
          - Incrementing growth cycle to $NEW_CYCLE and generation to $NEW_GENERATION.
          - Updating \`evolution-metrics.json\` with the latest statistics.
          - Modifying \`README.md\` to reflect these new metrics within the \`AI-EVOLUTION-MARKER\` block.

          ## ðŸ§¬ Proposed Enhancements for v0.3.0 (Next Evolution)

          Based on the current trajectory, the next evolutionary step (v0.3.0) should focus on:

          1.  **True AI Integration (Conceptual):**
              *   Abstract the AI call: Create a script/interface (e.g., \`src/ai_interface.sh\`) that this workflow calls. Initially, it can use this simulation logic, but can be swapped for a real LLM call.
              *   Define a clear API for the AI: What inputs it needs, what outputs (JSON structure) it must provide.
          2.  **Smarter Context Collection:**
              *   Prioritize files based on recent changes or importance tags.
              *   Allow dynamic adjustment of \`max_context_files\` and \`max_context_line_per_file\` based on prompt complexity.
          3.  **Advanced README Updates:**
              *   Instead of just metrics, allow AI to add sections to README for new features (still using markers).
          4.  **Modular Growth Actions:**
              *   Define specific "growth action types" in the AI response (e.g., \`create_file\`, \`modify_function\`, \`add_test\`, \`update_docs\`) beyond simple file replacement.

          ## ðŸš€ Planting this Evolved Seed

          To continue evolution towards v0.3.0:
          1.  Review and merge the Pull Request from this growth cycle.
          2.  This \`.seed.md\` file now contains the refined blueprint.
          3.  The next run of \`ai_evolver.yml\` will use the evolved codebase as its starting point.

          ---
          *ðŸŒ± Generated by AI Evolution Engine v0.2.0 Workflow*
          *"From sapling to forest, one cycle at a time."*
          EOF_NEXT_SEED
          )

                    # Construct the AI response JSON
                    # The AI will provide instructions to modify README using sed for the dynamic block
                    # and full content for evolution-metrics.json
                    cat > "$RESPONSE_FILE" <<EOF_RESPONSE
          {
            "growth_id": "$(uuidgen)",
            "new_branch": "growth/$(date +%Y%m%d-%H%M%S)-${{ inputs.growth_mode }}-$NEW_CYCLE",
            "changes": [
              {
                "path": "evolution-metrics.json",
                "action": "replace_content",
                "content": $(echo "$NEW_METRICS_CONTENT" | jq -Rsa)
              },
              {
                "path": "README.md",
                "action": "update_readme_block",
                "marker_start": "$README_MARKER_START",
                "marker_end": "$README_MARKER_END",
                "new_block_content": $(echo "$README_DYNAMIC_CONTENT_FOR_AI_RESPONSE" | jq -Rsa)
              }
              // Add other simulated file changes here if needed
              // e.g., { "path": "src/new_module.py", "action": "create", "content": "# New AI Module\nprint('Hello from AI')" }
            ],
            "commit_message": "ðŸŒ¿ Growth Cycle #$NEW_CYCLE: ${{ inputs.prompt }}",
            "next_seed_content": $(echo "$NEXT_SEED_CONTENT" | jq -Rsa)
          }
          EOF_RESPONSE
                    echo "AI simulation response generated: $RESPONSE_FILE"
                    cat $RESPONSE_FILE # For debugging

                - name: ðŸŒ¾ Apply Growth Changes
                  run: |
                    echo "ðŸŒ¾ Applying evolutionary changes..."
                    RESPONSE_FILE="/tmp/evolution_response.json"
                    BRANCH_NAME=$(jq -r .new_branch "$RESPONSE_FILE")
                    
                    echo "Creating and switching to new branch: $BRANCH_NAME"
                    git checkout -b "$BRANCH_NAME"
                    
                    # Apply file changes from AI response
                    jq -c '.changes[]' "$RESPONSE_FILE" | while read -r change_json; do
                      path=$(echo "$change_json" | jq -r '.path')
                      action=$(echo "$change_json" | jq -r '.action')
                      
                      mkdir -p "$(dirname "$path")"
                      echo "Processing change for $path (Action: $action)"

                      if [ "$action" == "replace_content" ]; then
                        content=$(echo "$change_json" | jq -r '.content')
                        echo -e "$content" > "$path"
                        echo "âœ“ Content replaced for $path"
                      elif [ "$action" == "create" ]; then
                        content=$(echo "$change_json" | jq -r '.content')
                        echo -e "$content" > "$path"
                        echo "âœ“ File created: $path"
                      elif [ "$action" == "update_readme_block" ]; then
                        # More robust way to handle multiline content for sed
                        # The new_block_content is already escaped (\\n) from jq -Rsa
                        # marker_start=$(echo "$change_json" | jq -r '.marker_start') # Not needed if fixed
                        # marker_end=$(echo "$change_json" | jq -r '.marker_end') # Not needed if fixed
                        new_block_content_escaped_for_sed=$(echo "$change_json" | jq -r '.new_block_content')
                        
                        # Use awk for safer multiline replacement between markers
                        awk -v start="<!-- AI-EVOLUTION-MARKER:START -->" \
                            -v end="<!-- AI-EVOLUTION-MARKER:END -->" \
                            -v new_content="$new_block_content_escaped_for_sed" '
                        BEGIN { p = 1 }
                        $0 == start { print; print new_content; p = 0; next }
                        $0 == end { p = 1 }
                        p { print }
                        ' "$path" > "${path}.tmp" && mv "${path}.tmp" "$path"
                        echo "âœ“ README.md block updated for $path"
                      else
                        echo "Unknown action: $action for $path"
                      fi
                    done
                    
                    # Commit growth (evolution-metrics.json is updated via replace_content)
                    git add -A
                    COMMIT_MSG=$(jq -r .commit_message "$RESPONSE_FILE")
                    git commit -m "$COMMIT_MSG" || echo "No changes to commit, or commit failed."
                    git push origin "$BRANCH_NAME"
                    
                - name: ðŸŒ° Plant New Seeds (Generate .seed.md for next evolution)
                  if: ${{ inputs.auto_plant_seeds == true }}
                  run: |
                    echo "ðŸŒ° Generating next generation .seed.md..."
                    RESPONSE_FILE="/tmp/evolution_response.json"
                    NEXT_SEED_CONTENT=$(jq -r .next_seed_content "$RESPONSE_FILE")
                    
                    echo -e "$NEXT_SEED_CONTENT" > .seed.md
                    echo "âœ“ New .seed.md generated for the next evolutionary cycle."
                    
                    git add .seed.md
                    git commit -m "ðŸŒ° Planted new seed for next evolution (post cycle $(jq -r '.changes[] | select(.path=="evolution-metrics.json") | .content' "$RESPONSE_FILE" | jq -r .growth_cycles))" || echo "No changes to .seed.md or commit failed."
                    git push origin "$BRANCH_NAME" || true # Allow if branch already up-to-date
                    
                - name: ðŸŒ³ Create Growth Pull Request
                  env:
                    GH_TOKEN: ${{ github.token }}
                  run: |
                    RESPONSE_FILE="/tmp/evolution_response.json"
                    BRANCH_NAME=$(jq -r .new_branch "$RESPONSE_FILE")
                    COMMIT_MSG=$(jq -r .commit_message "$RESPONSE_FILE")
                    NEXT_SEED_PREVIEW=$(jq -r .next_seed_content "$RESPONSE_FILE" | head -n 20) # Preview of next seed
                    
                    PR_BODY=$(cat <<EOF_PR_BODY
          ## ðŸŒ± AI-Driven Growth Cycle Completed

          **Growth Mode:** ${{ inputs.growth_mode }}
          **Original Prompt:** "${{ inputs.prompt }}"

          ### ðŸŒ¿ Summary of Changes in this Cycle:
          This cycle focused on evolving the codebase based on the prompt. Key changes include:
          - Updates to \`evolution-metrics.json\`.
          - Modifications to \`README.md\` dynamic block.
          - Other changes as per the AI's plan (see commit details).

          ### ðŸŒ° Next Generation Seed (.seed.md) Highlights:
          The following \`.seed.md\` has been generated to guide the next evolution:
          \`\`\`markdown
          ${NEXT_SEED_PREVIEW}
          ... (see .seed.md in branch for full content)
          \`\`\`

          ---
          *Generated by AI Evolution Engine v0.2.0 Workflow ðŸŒ±*
          *Commit: ${COMMIT_MSG}*
          EOF_PR_BODY
          )
                    
                    gh pr create \
                      --title "$COMMIT_MSG" \
                      --body "$PR_BODY" \
                      --base main \
                      --head "$BRANCH_NAME"
